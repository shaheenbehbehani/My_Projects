# -*- coding: utf-8 -*-
"""Tech Salary Insights.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bj_ZvIVrb2pZvV1yT5x_VJ5t2M6VJ1Lh

# Tech Salary Insights: Empowering Careers with Open Data

Topic: AI, ML, Datascientist job market trend

## Executive Summary

This report provides a comprehensive analysis of salary trends within the fields of AI, Machine Learning, Data Science, and related disciplines. Drawing from a dataset of 59,479 records spanning 2020 to 2024, the analysis explores the influence of factors such as experience level, company size, employment type, remote work ratio, and regional disparities on earnings. The findings reveal that senior and executive roles command the highest salaries, with Machine Learning Engineers and AI Researchers leading in compensation, earning average salaries exceeding \$200,000. Medium-sized companies dominate the job market, offering competitive pay across most roles, while small companies lag significantly in salary offerings. Remote work, which constitutes 22% of the dataset, provides competitive compensation but slightly lower than on-site roles, which remain the highest-paying category.

Regional analysis highlights the United States as the primary driver of high salaries, with limited representation from other regions such as Asia and Africa. Additionally, salary growth trends from 2020 to 2024 indicate significant increases for roles like Machine Learning Engineer and Data Scientist, reflecting their sustained demand and importance. However, entry-level roles, such as Data Analyst, offer lower starting pay but serve as a gateway to higher-paying positions with specialization and experience.

While the report offers valuable insights into current market dynamics, limitations in regional representation, historical depth, and emerging roles were noted. Expanding the dataset and incorporating advanced forecasting models could provide a more global and forward-looking perspective. This report equips stakeholders—including job seekers and employers—with actionable insights to navigate the evolving job market, optimize workforce strategies, and align career decisions with high-growth opportunities in the tech industry.

## Table of Contents

### Introduction

**Purpose of the Report**

The purpose of this report is to provide an in-depth analysis of salary trends within various job roles, employment types, and company characteristics. Specifically, we aim to understand how factors like experience level, company size, employment type, and remote work ratio influence earnings across different sectors. By conducting a thorough investigation of these elements, this report seeks to equip stakeholders—such as employers, job seekers, and policymakers—with valuable insights that can inform decision-making and workforce planning.



**Background and Source of the Dataset**

The dataset used for this analysis contains 59,479 records with detailed information about job roles, salaries, company locations, employment types, and other job characteristics. It was sourced from a public dataset available at aijobs.net, which collects salary information anonymously from professionals and employers all over the world and makes it publicly available for anyone to use, share, and play around with. Supplementary data was merged from external CSV files to provide additional context. Specifically, we utilized a CSV file from GitHub by the author Arturictus that included country abbreviations and full names to simplify the analysis of company and employee locations. The dataset covers a period between 2020 and 2024, with records spanning multiple regions, including the Americas, Europe, Asia, Oceania, and Africa. This comprehensive coverage allows us to evaluate trends from a global perspective.



**Our Research Questions**

The following research questions guided our analysis:

* Is there a correlation between experience level and salary? How strong is this relationship?

* Does company size affect compensation for specific experience levels?

* How does employment type influence salary trends across different experience levels?

* What are the salary differences across company locations, and which countries have the highest or lowest average salaries?

* Is there a relationship between remote work ratio and salary? Are fully on-site roles compensated differently than fully remote roles?

* How have salaries for popular data-related roles changed from 2020 to 2024, and what trends can we observe?

* Which job roles currently offer the highest average salaries, and how do these roles vary by experience level?

**Importance of the Purpose and Questions**

The analysis of salary trends is crucial for various reasons. Understanding how different factors impact earnings is valuable for job seekers aiming to make informed career decisions, particularly in a competitive job market. Employers can also use these insights to shape compensation strategies and attract the right talent, while policymakers may gain a better understanding of market dynamics that could influence workforce development programs. Evidence shows that salary disparities across different roles and experience levels often reflect underlying biases or market dynamics that need to be addressed to promote a fairer labor market. For instance, the prevalence of certain roles in specific regions or the wage gap between on-site and remote positions can indicate broader socio-economic issues. Thus, the questions outlined above aim to address not only salary differences but also their implications for equity and opportunity in the workplace.

**Approach and Methods Used**

The approach taken to analyze the data involved several key steps. First, we performed data cleaning, which included removing unnecessary columns (such as salary in non-standardized currencies) and merging external data to enhance location-related fields. We also dropped missing values and filtered out outliers to ensure the reliability of our findings.

Next, we applied various data analysis techniques, including correlation analysis, grouping, and mean calculations, to explore relationships between experience levels, company sizes, employment types, and salaries. To visualize our findings, we used bar charts, box plots, scatter plots, and geographic visualizations, all created using libraries such as Matplotlib, Seaborn, and Plotly.

Furthermore, we implemented linear regression modeling to forecast salary trends for popular job roles from 2025 to 2029, allowing us to anticipate future salary dynamics. The analysis also included evaluating the top 10 highest and lowest-paying company locations, comparing salaries across company sizes, and assessing trends for specific experience levels and employment types. Our goal was to provide both a current snapshot and forward-looking insights into salary distribution across the job market.

### Main Content and Analysis

#### Import package here
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from matplotlib.colors import LinearSegmentedColormap
import plotly.express as px

"""####load csv file here

"""

df = pd.read_csv('ourdf.csv', encoding = 'latin-1')
df.head()

"""#### Data Cleaning and Merging

Before we start to analyze our datasets, here are couple things that we have to consider, let's take a look of some general informations about our dataset:

The dataset contains 59,479 rows and 11 columns. Here is a summary of the columns:

work_year: The year the salary was paid (integer type).

experience_level: The experience level of the employee (object type):


* EN: Entry-level / Junior
* MI: Mid-level / Intermediate
* SE: Senior-level / Expert
* EX: Executive-level / Director

employment_type: The type of employment (object type):

* PT: Part-time
* FT: Full-time
* CT: Contract
* FL: Freelance

job_title: The title of the job (object type).

salary: The salary amount in the original currency (integer type).

salary_currency: The currency in which the salary is provided (object type).

salary_in_usd: The salary of the employee in USD (integer type).

employee_residence: The location of the employee's residence (object type).

remote_ratio: The overall amount of work done remotely: (integer type):

* 0: No remote work (less than 20%)

* 50: Partially remote/hybird

* 100: Fully remote (more than 80%)

company_location: The location of the company (object type).

company_size: The size of the company (object type):

* S: less than 50 employees (small)

* M: 50 to 250 employees (medium)

* L: more than 250 employees (large)
"""

#basic info of df
df.info()

#check na value
df.isna().sum()

"""Fortunately, no NaN values exist after checking the sum for each column. However, there are two columns that we need to drop: `salary` and `salary_currency`. These columns are unnecessary for our analysis because we already have `salary_in_usd`, which standardizes all values in USD, making our research simpler and more consistent."""

'''
#remove two other salary columns
df = df.drop(['salary', 'salary_currency'], axis=1)
df
'''

"""####Merging

Another important step involves addressing the `employee_residence` and `company_location` columns, where all countries are represented using abbreviations. These abbreviations might be difficult to interpret, especially if we are unfamiliar with some of them. To resolve this, we located a CSV file on GitHub called `all_abbreviation.csv` ([link](https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes/blob/master/all/all.csv)) that provides comprehensive information about country abbreviations, including their full names and regions. We merged this dataset with our own, adding a `name` column and a `region` column to facilitate further analysis.
"""

'''
abb = pd.read_csv('all_abbreviation.csv')
#slice columns
abb = abb[['name', 'alpha-2', 'region', 'sub-region']]

#merge to main df
df = df.merge(abb, left_on='company_location', right_on='alpha-2', how='left')
df = df.drop('alpha-2', axis=1)

#save to csv
df.to_csv('ourdf.csv', index=False)
'''

"""We save our new df to a csv file called `ourdf.csv`. With the data cleaning and merging steps now complete, we are ready to proceed with the analysis.

####Job market collection overview

The second step of our analysis is to understand the dataset first, this step is very crucial for us for further decision making and question forming.

**Company Location Overview**

The `company_location` column in the dataset contains 59,479 entries representing company locations, with 82 unique locations identified. The most frequently occurring location is the United States (US), accounting for a significant majority with 53,949 entries, followed by Canada (CA) and Great Britain (GB) with 1,925 and 1,702 entries respectively. Other notable locations include Germany (DE), Australia (AU), Spain (ES), and France (FR), though their counts drop significantly compared to the US. The data shows a strong concentration of companies in the US, suggesting it as the dominant location in this dataset, with other regions having considerably smaller representation. So for our further Analysis, we have to adjust some of our approaches to address some bias.
"""

#Company location overview
df['company_location'].value_counts()

"""**Region Overview**

As anticipated, 94.2% of the records belong to the Americas, with 4.9% coming from Europe and only a small fraction representing regions like Asia, Oceania, and Africa. This significant imbalance makes it challenging to conduct a comprehensive international analysis due to the limited data available for other regions.

"""

#region
result = df['region'].value_counts() / df['region'].count()
result.round(3)

"""**Work year distribution**

Most of the data is concentrated on recent years, particularly 2024, with fewer entries as we look further back. This indicates that the dataset is strongly focused on current or upcoming work years, which is encouraging for analyzing recent trends. However, the limited data for earlier years, such as 2021 and 2020, with only 218 and 75 records respectively, may pose challenges for drawing meaningful insights from those periods.

"""

#work year distribution
count = df['work_year'].value_counts()
count

"""**Experience level distribution**

The largest segment, SE (Senior), accounts for 59.2% of the total, showing that the majority of entries pertain to senior-level professionals. MI (Mid-level) follows with 29.6%, indicating a substantial representation of mid-level professionals. EN (Entry-level) makes up 9.2%, suggesting a smaller proportion of less experienced individuals, while EX (Executive) is the smallest category at 2.1%, representing only a minor share of the data. This highlights a strong focus on experienced professionals (senior and mid-level), with limited data on entry-level and executive roles.

"""

#experience level overview
# Count data
count = df['experience_level'].value_counts()

# Define colors for the chart
colors = plt.cm.Paired(range(len(count)))

# Explode the first slice slightly for emphasis (adjust as needed)
explode = [0.1] + [0] * (len(count) - 1)

# Create the pie chart
plt.figure(figsize=(8, 8))  # Adjust figure size for better layout
plt.pie(
    count,
    labels=count.index,
    autopct='%1.1f%%',
    startangle=90,
    explode=explode,
    colors=colors,
    shadow=True
)

# Add title
plt.title('Experience Level', fontsize=16)

# Add legend for better clarity
plt.legend(count.index, title="Levels", loc="upper right")

# Display the chart
plt.show()

"""**Employment Type Distribution**

By examining the employment type in this dataset, we found that 99.6% of the records represent full-time employees. This suggests that any analysis related to employment type should account for this imbalance, as the data heavily skews towards full-time roles.

"""

#employment type distribution
result = df['employment_type'].value_counts() / df['employment_type'].count()
result.round(3)

"""**Company Size Overview**

In this dataset, the majority of companies are medium-sized, accounting for 96.2% of the records. Large companies make up 3.4%, while small companies represent only a small fraction. This imbalance may present a limitation when conducting analyses related to company size, as the data is heavily skewed towards medium-sized companies.

"""

#company size
result = df['company_size'].value_counts() / df['company_size'].count()
result.round(3)

"""**Remote Ratio**

A significant majority, 77.6%, of the roles are fully on-site, indicating that most employees work in traditional office settings with no remote work. Fully remote roles make up 22.0% of the dataset, showing that nearly one in five positions allows employees to work entirely from home. In contrast, hybrid or partially remote roles are rare, accounting for only 0.5% of the data. This distribution suggests a strong emphasis on on-site work, with remote and hybrid arrangements being much less common.

"""

# Count data
result = df['remote_ratio'].value_counts()

# Define colors for the pie chart
colors = plt.cm.Set3(range(len(result)))

# Explode the first slice for emphasis (adjust as needed)
explode = [0.1 if i == 0 else 0 for i in range(len(result))]

# Create the pie chart
plt.figure(figsize=(8, 8))  # Adjust figure size for better layout
plt.pie(
    result,
    labels=result.index,
    autopct='%1.1f%%',
    startangle=90,
    explode=explode,
    colors=colors,
    shadow=True
)

# Add a title
plt.title('Remote Ratio', fontsize=16)

# Add a legend for clarity
plt.legend(result.index, title="Remote Work Levels", loc="upper right")

# Display the chart
plt.show()

"""**Overview conclusion**

In conclusion, the dataset offers valuable insights into key trends, particularly in the Americas (94.2%) and the United States (90.7%), where the majority of companies are located. Its focus on recent years, especially 2024, provides a strong foundation for analyzing current and emerging trends. The data highlights a significant presence of senior (59.2%) and mid-level professionals (29.6%), making it well-suited for studying the dynamics of experienced talent. Additionally, the dominance of full-time employment (99.6%), medium-sized companies (96.2%), and on-site roles (77.6%) offers a clear view of these prevalent employment patterns, while fully remote positions (22%) reflect evolving workplace preferences.

However, there are aspects to be mindful of during analysis. The limited representation from regions outside the Americas, as well as smaller datasets for entry-level and executive roles, part-time employment, small and large companies, and earlier years (e.g., 2021 and 2020), may introduce biases. To maximize the dataset's potential, analyses should leverage its strengths while acknowledging areas with less coverage to ensure balanced and accurate interpretations.

####Is there a correlation between experience level and salary? How strong is this relationship?

To explore the research question, "Is there a correlation between experience level and salary, and how strong is this relationship?", we assigned numeric values to the experience levels using a mapping where entry-level (EN) corresponds to 1, mid-level (MI) to 2, senior-level (SE) to 3, and executive-level (EX) to 4. This allowed us to quantify the experience levels and analyze their relationship with salary.

We then calculated the correlation between the numeric experience levels and salaries in USD. The resulting correlation coefficient provides insight into the strength and direction of this relationship. A positive value would indicate that salary tends to increase with higher experience levels, while the magnitude of the coefficient determines how strong this correlation is.
"""

# Map experience levels to numeric values
experience_map = {'EN': 1, 'MI': 2, 'SE': 3, 'EX': 4}
df['experience_numeric'] = df['experience_level'].map(experience_map)

# Calculate the correlation between experience level and salary
correlation = df['experience_numeric'].corr(df['salary_in_usd'])
correlation

"""The correlation coefficient between experience level and salary is approximately 0.31, indicating a positive but moderate relationship. This suggests that as experience level increases, salary tends to rise, but the relationship is not particularly strong. Other factors, such as employment type, industry, or location, may also play significant roles in determining salary beyond just experience level. While experience does have a positive impact, it is not the sole or dominant factor influencing earnings.

####Avg salary by experience level

To calculate the average salary by experience level in the dataset, we first group the data by the column representing experience levels, `'experience_level'`. By doing this, we essentially organize the data into categories based on each unique experience level present in the dataset.

Next, we apply the `mean()` function to the `'salary_in_usd'` column within each experience-level group. This function computes the average salary for each group. The resulting values are then sorted in descending order using `sort_values(ascending=False)`, ensuring the experience levels with the highest average salaries appear at the top of the output.

Finally, to refine the presentation of the averages, we use the `round(3)` method to round the values to three decimal places. This step ensures clarity and uniformity in the results.
"""

#Avg salary by experience level
result = df.groupby('experience_level')['salary_in_usd'].mean().sort_values(ascending=False)
result.round(3)

"""To create a visually compelling bar plot with a gradient color scheme, we begin by setting up a figure and axes using `plt.subplots` with specified dimensions. The gradient is applied to highlight variations in average salary by experience level.

We plot the data using `ax.bar`, which takes the experience levels (`result.index`) as categories on the x-axis and their corresponding average salaries (`result.values`) as bar heights. To achieve the gradient effect, we normalize the salary values using `plt.Normalize`, scaling them to fit within the range of the colormap `viridis`. The normalized values are then mapped to colors from the colormap.

Using a loop, we assign each bar in the plot a color from the gradient based on its normalized value. This ensures that the bars are visually distinguishable, with shades representing relative salary differences.

Next, we enhance the plot with a descriptive title, axis labels, and ticks. The x-axis labels are kept horizontal (`rotation=0`) to maintain readability.

To make the gradient meaningful, we add a colorbar to the plot using `plt.colorbar`. The colorbar serves as a visual scale, with its label indicating the corresponding salary range.

Finally, we display the plot using `plt.show`, which brings the visualization to life, making it easy to interpret the relationship between experience level and average salary.


"""

# Create a bar plot with a gradient color
fig, ax = plt.subplots(figsize=(8, 6))

# Data
bars = ax.bar(result.index, result.values)

# Apply a gradient colormap
norm = plt.Normalize(result.values.min(), result.values.max())
colors = plt.cm.viridis(norm(result.values))

for bar, color in zip(bars, colors):
    bar.set_color(color)

# Add labels and title
plt.title('Avg Salary by Experience Level', fontsize=16)
plt.xlabel('Experience Level', fontsize=12)
plt.ylabel('Avg Salary', fontsize=12)
plt.xticks(rotation=0)

# Add a colorbar to represent the gradient scale
sm = plt.cm.ScalarMappable(cmap="viridis", norm=norm)
sm.set_array([])
cbar = plt.colorbar(sm, ax=ax)
cbar.set_label('Salary Scale', fontsize=12)

# Display the plot
plt.show()

"""We also create an elegant and informative visualization of salary distribution by experience level, we used a box plot, leveraging the `seaborn` library's customization capabilities.

First, we applied the `"whitegrid"` style using `sns.set_style` to ensure the plot background is clean and professional. We then defined the figure size with `plt.figure(figsize=(10, 7))` to make the visualization spacious and readable.

The box plot was created with `sns.boxplot`, specifying `experience_level` as the x-axis and `salary_in_usd` as the y-axis. The `data` parameter was set to our dataset (`df`), while the `order` parameter ensured a logical arrangement of experience levels—'EN' (Entry), 'MI' (Mid), 'SE' (Senior), and 'EX' (Executive). For visual appeal, we applied the `coolwarm` colormap, blending cool and warm tones.

Next, we enhanced the plot's title and labels by increasing font size, adding padding, and using bold styling for the title. To improve readability, a horizontal grid was added along the y-axis with a dashed line style and reduced opacity.

For a cleaner look, we used `sns.despine` to remove the top and right spines of the plot, ensuring the focus remains on the data.

Finally, the plot was displayed using `plt.show`, resulting in an aesthetic and functional representation of the salary distribution by experience level.
"""

# Set a style for the plot
sns.set_style("whitegrid")

# Create the box plot
plt.figure(figsize=(10, 7))  # Larger figure for better visualization
sns.boxplot(
    x='experience_level',
    y='salary_in_usd',
    data=df,
    order=['EN', 'MI', 'SE', 'EX'],
    palette="coolwarm"  # Use a gradient colormap for aesthetics
)

# Add title and labels with improved styling
plt.title('Salary Distribution by Experience Level', fontsize=16, fontweight='bold')
plt.xlabel('Experience Level', fontsize=12, labelpad=10)
plt.ylabel('Salary in USD', fontsize=12, labelpad=10)

# Add a horizontal grid for easier reading
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Remove the top and right spines for a cleaner look
sns.despine()

# Display the plot
plt.show()

"""We analyzed the average salaries in USD based on different experience levels to understand how experience impacts earnings. The results reveal that professionals with executive-level experience (EX) earn the highest average salary, at 201,246.24. This is followed by senior-level professionals (SE), whose average salary is 173,784.36. Mid-level professionals (MI) earn a lower average of 143,677.69, while entry-level professionals (EN) have the lowest average salary of 103,817.18. This progression highlights a clear relationship between experience and earning potential, with salaries increasing as experience levels advance.

####Top/bottom 10 company location by Avg salary

We began by calculating the average salary in USD for each company, grouping the data by company name, and identifying the top 10 and bottom 10 companies based on these averages. To make the data more structured, we converted both groups into separate DataFrames. Next, we added a column to each DataFrame to indicate their rank as either "top10" or "bottom10." To ensure the data was clean and ready for further analysis, we reset the index for both DataFrames and then set the "rank" column as the new index. Finally, we combined the two DataFrames into a single cohesive dataset, allowing us to easily compare and analyze the top and bottom 10 companies side by side.
"""

#top 10 by company location
top_10 = df.groupby('name')['salary_in_usd'].mean().sort_values(ascending=False).head(10)
bottom_10 = df.groupby('name')['salary_in_usd'].mean().sort_values(ascending=False).tail(10)

#To df
top_10 = pd.DataFrame(top_10)
bottom_10 = pd.DataFrame(bottom_10)

#add columns
top_10['rank'] = 'top10'
bottom_10['rank'] = 'bottom10'

#reset index
top_10 = top_10.reset_index()
bottom_10 = bottom_10.reset_index()

#set index
top_10 = top_10.set_index('rank')
bottom_10 = bottom_10.set_index('rank')

#combine 2 dfs
top_bottom_10 = pd.concat([top_10, bottom_10])

top_bottom_10

"""After getting all the tables. We begin by setting up the figure and axis using `plt.subplots`, specifying a figure size to ensure readability. The top 10 companies' data is plotted on the primary x-axis using `ax.bar`, with blue-colored bars representing their average salaries. For the bottom 10 companies, we utilize a secondary x-axis (`ax.twiny`) and plot the bars in red to distinguish them clearly from the top 10.

To make the axes more intuitive, we customize each x-axis separately. The primary x-axis (`ax`) is labeled for the top 10 companies, with the labels rotated slightly for better readability and styled in blue to match the bar colors. Similarly, the secondary x-axis (`ax2`) is labeled for the bottom 10 companies, with labels styled in red.

Annotations are added to each bar to display the average salary values directly above the bars. These annotations are color-coded (blue for the top 10, red for the bottom 10) to maintain consistency with the respective bar colors.

We also include a legend to differentiate between the top and bottom 10 companies, placing it at the top-left corner of the plot. The title, styled appropriately, clearly communicates the purpose of the visualization.

Finally, we use `plt.tight_layout` to optimize spacing, ensuring that all elements of the chart are neatly arranged without overlapping. The resulting visualization effectively highlights the salary differences across the top and bottom companies, making the data easy to interpret and visually engaging.
"""

# Improved stacked bar chart for top_10 and bottom_10
fig, ax = plt.subplots(figsize=(12, 8))

# Plot top 10 bars
top_bars = ax.bar(top_10['name'], top_10['salary_in_usd'], color='blue', label='Top 10')

# Plot bottom 10 bars using secondary x-axis
ax2 = ax.twiny()
bottom_bars = ax2.bar(bottom_10['name'], bottom_10['salary_in_usd'], color='red', label='Bottom 10')

# Customize the primary x-axis (Top 10)
ax.set_xlabel('Company Location (Top 10)', fontsize=12, color='blue')
ax.set_ylabel('Average Salary (USD)', fontsize=12)
ax.tick_params(axis='x', labelrotation=45, labelsize=10)
ax.grid(axis='y', linestyle='--', alpha=0.7)
ax.set_xticklabels(top_10['name'], color = 'blue')

# Customize the secondary x-axis (Bottom 10)
ax2.set_xlabel('Company Location (Bottom 10)', fontsize=12, color='red')
ax2.tick_params(axis='x', labelrotation=45, labelsize=10)
ax2.set_xticklabels(bottom_10['name'], color = 'red')

# Annotate top 10 bars
for bar in top_bars:
    height = bar.get_height()
    ax.annotate(f'{int(height):,}', xy=(bar.get_x() + bar.get_width() / 2, height),
                xytext=(0, 5), textcoords='offset points', ha='center', fontsize=10, color='blue')

# Annotate bottom 10 bars
for bar in bottom_bars:
    height = bar.get_height()
    ax2.annotate(f'{int(height):,}', xy=(bar.get_x() + bar.get_width() / 2, height),
                 xytext=(0, 5), textcoords='offset points', ha='center', fontsize=10, color='red')

# Add legend for both bars
fig.legend(loc='upper left', fontsize=12)

# Add a title to the plot
ax.set_title('Top 10 and Bottom 10 Companies by Avg Salary', fontsize=14)

# Adjust layout for better spacing
plt.tight_layout()
plt.show()

"""We found a significant disparity in average salaries across different company locations. Among the top 10, Qatar leads with the highest average salary of 300,000, followed by Venezuela at 192,500 and Puerto Rico at 167,500. The United States also ranks high with an average of 164,405, alongside other countries like Israel, Saudi Arabia, and Canada, which show strong salary averages above 130,000. In contrast, the bottom 10 locations reveal much lower averages, with Ecuador at the lowest, offering just 16,000, and Moldova slightly higher at 18,000. Other locations like Thailand, Ghana, and the Philippines also fall into the lower salary range, averaging below 40,000.

#### Avg salary world Map

In this process, we analyze and visualize average salary data by country using Python. Here's how we approach it step by step:

We start by grouping the data by country name. Specifically, we calculate the mean salary in USD for each country using the `groupby` method on the column `name` (which represents country names) and then applying the `mean()` function to the `salary_in_usd` column. The result is assigned to `avg_salary_by_country`.

Next, we convert `avg_salary_by_country` into a DataFrame to ensure it's in the correct structure for further manipulations.

After that, we reset the index of this DataFrame. This step ensures the country names and corresponding average salaries become standard columns rather than part of the index.

Because we need to align the country names in our data with Plotly's built-in country codes for accurate visualization, we map and replace some names. A dictionary `name_mapping` is created with country names as keys and their corresponding corrected names as values. Using the `replace` method, we update the `name` column to ensure compatibility.

To visualize the data, we use a scatter plot on a geographic map via Plotly's `scatter_geo`. We set up the visualization so that each country appears on the map with a circle whose size corresponds to the average salary and color represents its value. Features like `hover_name` and `hover_data` allow users to view detailed salary information on hover. The map projection is set to "natural earth," and we choose the `Viridis` color scale for clarity.

The layout of the visualization is customized. The title is positioned centrally at the top, with increased font size for emphasis. The map’s geographical settings are configured to remove the frame but include coastlines, and we adjust the projection scale to ensure better visual proportions. A color bar is added to the side, providing context for the color scale.

To highlight the top 10 countries with the highest salaries, we identify them using the `nlargest` function. For these countries, we add annotations directly on the map. Each annotation includes the country name and its corresponding salary, formatted for readability. These annotations are displayed as text elements positioned above the respective country markers.

Finally, we display the map using `fig.show()`, bringing all these elements together in an interactive visualization that effectively communicates the average salaries worldwide.
"""

#group data by country name
avg_salary_by_country = df.groupby('name')['salary_in_usd'].mean()

avg_salary_by_country = pd.DataFrame(avg_salary_by_country)

#reset index
avg_salary_by_country = avg_salary_by_country.reset_index()

# Some country names need to be adjusted for matching with plotly's built-in country codes
name_mapping = {
    'United States of America': 'United States',
    'United Kingdom of Great Britain and Northern Ireland': 'United Kingdom',
    'Russian Federation': 'Russia',
    'Korea, Republic of': 'South Korea',
    'Iran, Islamic Republic of': 'Iran',
    'TÌ?rkiye': 'Turkey',
    'Venezuela, Bolivarian Republic of': 'Venezuela',
    'Viet Nam': 'Vietnam'
}

avg_salary_by_country['name'] = avg_salary_by_country['name'].replace(name_mapping)

# Create the map
fig = px.scatter_geo(avg_salary_by_country,
                    locations='name',
                    locationmode='country names',
                    size='salary_in_usd',
                    hover_name='name',
                    hover_data={'name': False,
                              'salary_in_usd': ':$,.0f'},
                    title='Average Salaries Around the World',
                    size_max=50,
                    projection='natural earth',
                    color='salary_in_usd',
                    color_continuous_scale='Viridis')

# Update layout
fig.update_layout(
    title=dict(
        text='Average Salaries Around the World',
        x=0.5,
        y=0.95,
        xanchor='center',
        yanchor='top',
        font=dict(size=24)
    ),
    geo=dict(
        showframe=False,
        showcoastlines=True,
        projection_scale=1.2
    ),
    coloraxis_colorbar=dict(
        title='Salary (USD)',
        tickprefix='$',
        tickformat=',.0f'
    ),
    width=900,
    height=500
)

# Add annotations for top 10 highest salaries
top_5 = avg_salary_by_country.nlargest(10, 'salary_in_usd')
for _, row in top_5.iterrows():
    fig.add_scattergeo(
        locationmode='country names',
        locations=[row['name']],
        text=[f"{row['name']}<br>${int(row['salary_in_usd']):,}"],
        mode='text',
        textposition='top center',
        showlegend=False
    )

fig.show()

"""Users can explore the map interactively, searching for average salaries of interest and delving deeper into the data as they wish.

####Find mean salary across employment_typee and experience level

We analyzed the average salary by employment type and experience level to understand how these factors intersect. To do this, we grouped the data by both employment type and experience level, calculating the mean salary in USD for each combination. The resulting table was reshaped using an unstacked format, organizing the data for better readability.

Next, we restructured the rows to follow a logical progression of experience levels: entry-level (EN), mid-level (MI), senior-level (SE), and executive-level (EX). By categorizing and sorting the index accordingly, we ensured the data reflects a clear and intuitive hierarchy. This approach allows us to easily compare salary trends across both employment types and experience levels.
"""

#find mean salary across employment_typee and experience level
result = df.groupby(['employment_type', 'experience_level'])['salary_in_usd'].mean().unstack(level = 0)

#swap rank
result.index = pd.CategoricalIndex(result.index, categories=['EN', 'MI', 'SE', 'EX'], ordered=True)
result = result.sort_index()
result

"""To create visualization, we start by using the `plot` method with the `kind='bar'` argument to generate a bar plot from the `result` data. The `figsize=(12, 8)` parameter ensures the chart has an ample size for readability. To make the plot visually engaging, we apply a custom color palette consisting of distinct colors for each employment type.

A descriptive title and appropriately labeled axes are added using `plt.title`, `plt.xlabel`, and `plt.ylabel`. Font sizes are adjusted, and the title is styled with bold weight to ensure prominence.

Gridlines along the y-axis, styled with a dashed pattern and reduced opacity, improve readability by helping the viewer align values with the corresponding bars.

The legend is customized for clarity, with a title for context and a defined location (`upper left`) to avoid overlapping with the plot elements. Font sizes for the legend and its title are chosen to balance visibility and aesthetics.

To prevent overlap or crowding, the x-axis labels are rotated slightly and resized for better legibility. This is particularly useful when the labels contain longer or multiple categories.

Annotations are added to each bar using `ax.bar_label`, displaying the exact average salary values at the top of the bars. These labels are formatted as integers and positioned slightly above the edges of the bars for a clean look.

Finally, we use `plt.tight_layout` to optimize spacing, ensuring all plot components are well-arranged. The resulting visualization combines clarity, precision, and visual appeal, making it easy to compare average salaries across different employment types and experience levels.
"""

# Enhanced bar plot
ax = result.plot(kind='bar', figsize=(12, 8), color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'])  # Custom color palette

# Add title and axis labels
plt.title('Average Salary by Employment Type and Experience Level', fontsize=16, weight='bold')
plt.xlabel('Experience Level', fontsize=14)
plt.ylabel('Average Salary in USD', fontsize=14)

# Add gridlines
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Customize legend
plt.legend(title='Employment Type', fontsize=12, title_fontsize=14, loc='upper left')

# Rotate x-axis labels for better visibility
plt.xticks(rotation=45, fontsize=12)

# Annotate bars with values
for container in ax.containers:
    ax.bar_label(container, fmt='%.0f', label_type='edge', fontsize=10, padding=3)

# Adjust layout
plt.tight_layout()

# Display the plot
plt.show()

"""We analyzed the average salaries across different combinations of employment types and experience levels. For entry-level (EN) roles, full-time (FT) positions offer the highest average salary at 104,275, while freelance (FL) positions have the lowest at 60,000. Among mid-level (MI) roles, full-time (FT) positions again dominate with an average salary of 143,939, and freelance (FL) positions trail at 42,180. For senior-level (SE) roles, full-time (FT) employment remains the most lucrative at 173,873, whereas freelance (FL) positions average 52,891. Executive-level (EX) positions show a stark contrast: contract-based (CT) roles yield the highest average at 416,000, while part-time (PT) and freelance (FL) roles are either unavailable or significantly lower, with full-time (FT) roles averaging 201,073. These findings emphasize the significant influence of both employment type and experience level on earning potential.

####Are larger companies paying more for certain experience levels?

To answer this question, we organized the data to compare average salaries across company sizes and experience levels. Using grouping, we calculated the mean salary in USD for each combination of company size and experience level. The resulting table was unstacked to present company sizes as columns, making comparisons across experience levels straightforward.

To ensure logical ordering, we adjusted the rows to follow the natural progression of experience levels: entry-level (EN), mid-level (MI), senior-level (SE), and executive-level (EX). By categorizing and sorting the index, we created a clear and structured view of how salaries vary not only by experience level but also by the size of the company. This structured table offers insights into how company size impacts earning potential at different stages of experience.
"""

#sorting
company_size_salary_comparison = df.groupby(['company_size', 'experience_level'])['salary_in_usd'].mean().unstack(level = 0)

#swap rows for EX anmd SE
company_size_salary_comparison.index = pd.CategoricalIndex(company_size_salary_comparison.index, categories=['EN', 'MI', 'SE', 'EX'], ordered=True)
company_size_salary_comparison = company_size_salary_comparison.sort_index()
company_size_salary_comparison

"""Similar to the last research question, we begin by generating a bar plot using the `plot` method with `kind='bar'`. The `figsize=(12, 8)` parameter ensures that the visualization has ample space for readability. A custom color palette is applied to differentiate company sizes, and `edgecolor='black'` adds borders around the bars for better clarity and definition.

To make the plot descriptive and informative, a bold title is added with `plt.title`, and both axes are labeled with appropriately sized fonts for enhanced visibility. The x-axis labels are rotated slightly for clarity, but they remain horizontal (`rotation=0`) to ensure alignment with the bars.

Horizontal gridlines are incorporated using `plt.grid`, styled with dashed lines and reduced opacity to maintain a clean and unobtrusive appearance. This feature helps viewers align bar heights with corresponding salary values.

The legend is customized to specify the company size categories, with a title for context. Font sizes for both the legend and its title are adjusted for readability, and the legend is positioned in the upper-left corner to avoid overlap with the plot.

Each bar is annotated with its corresponding value using `ax.bar_label`, ensuring that salary values are clearly displayed. These annotations are formatted as integers, placed slightly above the bars, and styled for a clean look.

Finally, we apply `plt.tight_layout` to optimize spacing and prevent any labels or plot elements from being cut off. The result is a visually appealing and informative chart that allows for easy comparison of average salaries across different company sizes and experience levels.
"""

# Enhanced bar plot
ax = company_size_salary_comparison.plot(kind='bar', figsize=(12, 8),
                                         color=['#1f77b4', '#ff7f0e', '#2ca02c'],  # Custom colors
                                         edgecolor='black')  # Add bar borders for clarity

# Add title and axis labels
plt.title('Average Salary by Company Size and Experience Level', fontsize=16, weight='bold')
plt.xlabel('Experience Level', fontsize=14)
plt.ylabel('Average Salary in USD', fontsize=14)

# Rotate x-axis labels
plt.xticks(rotation=0, fontsize=12)

# Add gridlines
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Customize legend
plt.legend(title='Company Size', fontsize=12, title_fontsize=14, loc='upper left')

# Annotate bars with values
for container in ax.containers:
    ax.bar_label(container, fmt='%.0f', label_type='edge', fontsize=10, padding=3)

# Adjust layout to avoid label cutoff
plt.tight_layout()

# Display the plot
plt.show()

"""Our findings:

For entry-level (EN) positions, medium-sized companies offer the highest average salary at 104,435, followed closely by large companies at 99,117. Small companies, however, offer significantly lower salaries at 65,391.

For mid-level (MI) positions, large companies provide the highest average salary at 145,916, with medium-sized companies slightly trailing at 143,873. Small companies continue to lag, offering an average salary of 74,248.

For senior-level (SE) roles, medium-sized companies lead with an average salary of 173,986, closely followed by large companies at 171,025. Small companies still offer considerably lower salaries at 111,189.

For executive-level (EX) roles, medium-sized companies stand out, offering the highest average salary of 202,026. Large companies follow at 173,795, while small companies offer a comparable average of 169,172.

This data highlights how company size and experience level together influence salary, with medium and large companies generally providing better compensation, particularly at higher experience levels.

####Does the remote ratio affect salary?(ignore hybird)

We excluded hybrid roles from the dataset because they represent only 0.5% of the total data, which provides insufficient data points for meaningful analysis. After removing hybrid roles, we grouped the remaining data by the remote ratio and calculated the average salary in USD for each group. This approach allows us to focus on the relationship between remote work (fully remote or on-site) and average salary without the noise introduced by a category with very limited representation. The results provide insights into how the degree of remote work impacts earning potential.
"""

#slice hybird
no_hybird = df.loc[df['remote_ratio'] != 50]

#relation
result = no_hybird.groupby('remote_ratio')['salary_in_usd'].mean()
result

"""We then created a bar plot to visualize the relationship between remote ratio and average salary, excluding hybrid roles due to their minimal representation in the dataset. The x-axis represents the remote ratio categories (fully remote or on-site), and the y-axis shows the corresponding average salaries in USD.

The chart provides a clear comparison of how different levels of remote work influence salary trends. By keeping the x-axis labels horizontal, we enhanced the readability of the plot, making it easier to interpret and draw insights about salary variations across remote work arrangements.
"""

#bar plot
result.plot(kind='bar', figsize=(10, 6))
plt.title('Average Salary by Remote Ratio')
plt.xlabel('Remote Ratio')
plt.ylabel('Average Salary in USD')
plt.xticks(rotation=0)
plt.show()

"""We found that the average salary differs based on the remote ratio. Employees working on-site (remote ratio 0) have a higher average salary of 162,186 compared to those who work fully remotely (remote ratio 100), whose average salary is 149,491. This indicates that on-site roles tend to offer higher compensation compared to fully remote positions in our dataset. This difference may reflect variations in job requirements, industry norms, or other factors influencing salary based on work location.

#### Salary Trand from 2020 to 2024

In our analysis of salary trends from 2020 to 2024, we focused on the most popular job titles in our dataset. Initially, we identified the top five job titles by using the value_counts() method on the `job_title` column, which allowed us to pinpoint the most frequently occurring roles.

After establishing these top five titles, we created a subset of our original dataframe that included only the entries corresponding to these roles. This step was crucial as it enabled us to concentrate on the positions that are most relevant to our analysis.

We proceeded by grouping this filtered data according to work year and job title, calculating the average salary in USD for each combination. This provided us with a clear perspective on how salaries for these popular positions have changed over the years.

However, we made a significant decision to exclude `Software Engineer` from our analysis. Upon reviewing the data, we discovered that there were no previous data points available for this role prior to 2024. This lack of historical data could have skewed our findings and made it challenging to draw meaningful conclusions about salary trends for this position over time. By removing `Software Engineer`, we ensured that our analysis remained focused on roles with consistent data across all years.

Finally, we reset the index of our resulting dataframe to enhance its usability and clarity. The final output presents the average salaries for the selected job titles (excluding Software Engineer) from 2020 to 2024. This refined approach allows us to effectively track salary trends for some of the most common positions in our field, offering valuable insights into how compensation has evolved in recent years. This information can be particularly beneficial for job seekers, employers, and industry analysts looking to understand market dynamics.
"""

#popular job top 5
top5 = df['job_title'].value_counts().head(5)

#get index name
index_name = top5.index

#slice df
slice_df = df.loc[df['job_title'].isin(index_name)]

#group avg saleries by year and job title
slice_df = slice_df.groupby(['work_year', 'job_title'])['salary_in_usd'].mean()

#delete software engineer
slice_df = slice_df.drop(index = ('Software Engineer'), level = 1)

#reset index
slice_df = slice_df.reset_index()
slice_df

"""In our effort to visualize the salary trends for data-related jobs from 2020 to 2024, we created a comprehensive and visually appealing line plot. We began by setting up a larger figure size to ensure better visibility of our data. To enhance the aesthetic appeal and distinguish between different job roles, we chose a vibrant color palette using the Seaborn library's "husl" color scheme.

We then proceeded to plot the salary trends for four key roles: Data Analyst, Data Engineer, Data Scientist, and Machine Learning Engineer. For each role, we extracted the relevant data from our slice_df dataframe and plotted it on the graph. To differentiate between the roles, we assigned unique markers, line styles, and colors to each job title. This approach allows us to easily distinguish between the different trends at a glance.

To improve the readability of our graph, we customized the x-axis ticks to display each year from 2020 to 2024. We also added clear and concise labels for both axes, with "Year" on the x-axis and "Salary in USD" on the y-axis. The graph's title, "Salary Trends in Data-Related Jobs (2020-2024)," was prominently displayed using a larger font size and bold styling to draw attention.

We placed the legend in the upper left corner of the plot, ensuring it doesn't obstruct the data lines. To make the legend stand out, we added a frame with a shadow effect. For improved readability, we included a grid with dashed lines and slight transparency.

To enhance the overall appearance and interpretation of the data, we applied several formatting techniques. We used plt.FuncFormatter to add commas to the y-axis labels, making large salary figures easier to read. We also adjusted the layout to prevent any cut-off labels or titles.

This visualization allows us to easily compare salary trends across different data-related roles over the five-year period. It provides a clear and informative representation of how compensation has evolved in the data industry, which can be valuable for professionals, employers, and analysts in the field.
"""

# Create a larger figure for better visibility
fig, ax = plt.subplots(figsize=(12, 8))

# Define a color palette
colors = sns.color_palette("husl", 4)

# Data Analyst
data_analyst = slice_df.loc[slice_df['job_title'] == 'Data Analyst']
ax.plot(data_analyst['work_year'], data_analyst['salary_in_usd'],
        label='Data Analyst', marker='s', linestyle='-', linewidth=2, color=colors[0])

# Data Engineer
data_engineer = slice_df.loc[slice_df['job_title'] == 'Data Engineer']
ax.plot(data_engineer['work_year'], data_engineer['salary_in_usd'],
        label='Data Engineer', marker='o', linestyle='--', linewidth=2, color=colors[1])

# Data Scientist
data_scientist = slice_df.loc[slice_df['job_title'] == 'Data Scientist']
ax.plot(data_scientist['work_year'], data_scientist['salary_in_usd'],
        label='Data Scientist', marker='^', linestyle='-.', linewidth=2, color=colors[2])

# Machine Learning Engineer
machine_learning_engineer = slice_df.loc[slice_df['job_title'] == 'Machine Learning Engineer']
ax.plot(machine_learning_engineer['work_year'], machine_learning_engineer['salary_in_usd'],
        label='Machine Learning Engineer', marker='v', linestyle=':', linewidth=2, color=colors[3])

# Set x-axis ticks
ax.set_xticks(data_analyst['work_year'])
ax.set_xticklabels(data_analyst['work_year'])

# Title and axis labels with improved fonts
ax.set_title('Salary Trends in Data-Related Jobs (2020-2024)', fontsize=16, fontweight='bold')
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Salary in USD', fontsize=12)

# Customize the legend
ax.legend(loc='upper left', fontsize=10, frameon=True, fancybox=True, shadow=True)

# Add a grid for better readability
ax.grid(True, linestyle='--', alpha=0.7)

# Customize the layout
plt.tight_layout()

# Add commas to y-axis labels for better readability
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

# Show the plot
plt.show()

"""In our analysis of salary trends for data-related jobs from 2020 to 2024, we've uncovered several interesting patterns and insights.

Starting with Data Analysts, we observe a significant salary increase from 2020 to 2022, with the average salary jumping from 60,911 to 108,658. However, the growth seems to have plateaued after 2022, with only minor fluctuations in the following years. This suggests that the Data Analyst role may have reached a temporary ceiling in terms of compensation.

Data Engineers have experienced a steady increase in salaries over the five-year period. The average salary rose from 85,301 in 2020 to 150,446 in 2024, representing a substantial growth of about 76%. This consistent upward trend indicates a growing demand for Data Engineering skills in the job market.

Data Scientists saw an interesting salary trajectory. There was a slight dip in average salary from 2020 to 2021, dropping from 108,943 to 94,720. However, salaries rebounded strongly in 2022, reaching 139,644, and continued to rise, peaking at 163,855 in 2023. There was a slight decrease in 2024 to 160,043, but overall, the role has seen significant growth over the five-year period.

Machine Learning Engineers have consistently commanded the highest salaries among these roles. Starting at 119,916 in 2020, there was an unexpected drop to 91,367 in 2021. However, salaries for this role recovered dramatically, showing steep year-over-year increases from 2022 onwards. By 2024, the average salary for Machine Learning Engineers reached an impressive 200,447, marking a 67% increase from 2020 despite the dip in 2021.

We can conclude that all four roles have seen substantial salary growth over the five-year period, with Machine Learning Engineers and Data Engineers experiencing the most significant increases. The data suggests a strong demand for these skills in the job market, particularly for roles involving advanced analytics and machine learning. The temporary salary dips observed in some roles in 2021 could potentially be attributed to economic factors or market adjustments during that period.

It's worth noting that while Data Analysts have seen growth, their salary increases have been more modest compared to the other roles, potentially indicating a maturing of this position in the job market. On the other hand, the continued strong growth in Machine Learning Engineer salaries suggests that this specialization remains highly valued and in demand.

These findings provide valuable insights for professionals in the field, employers, and those considering a career in data-related roles, highlighting the dynamic nature of compensation in this rapidly evolving sector.

#### Linear Regression Forcasting 2025 - 2029 Continue...

In this code, we are working with a DataFrame called `slice_df` to analyze and forecast salary trends for different job titles. First, we filter the data for each job title—Data Analyst, Data Engineer, Data Scientist, and Machine Learning Engineer—by creating separate DataFrames for each role using conditional slicing with `.loc`.

Next, we define a function called `linear_regression`, which takes a DataFrame as input and fits a linear regression model to predict salaries (`salary_in_usd`) based on the year (`work_year`). The function returns the trained model.

To forecast future salaries, we define another function, `forcast_salary`, which takes a regression model and a list of future years (defaulting to 2025–2029). The function predicts salaries for these years, converts the results into a list, extracts the individual salary values, maps them into a dictionary with years as keys, and then converts this dictionary into a DataFrame with columns `work_year` and `salary_in_usd`.

Finally, we create a wrapper function, `linear_regression_forcast`, that combines the previous steps. This function takes a DataFrame as input, applies the linear regression model, uses the forecast function to predict future salaries, and returns the resulting DataFrame. This structure allows us to efficiently prepare and analyze salary trends for each job title.
"""

#continue using slice_df
slice_df

#prepare data for model for each job title
data_analyst = slice_df.loc[slice_df['job_title'] == 'Data Analyst']
print(data_analyst)
data_engineer = slice_df.loc[slice_df['job_title'] == 'Data Engineer']
data_scientist = slice_df.loc[slice_df['job_title'] == 'Data Scientist']
machine_learning_engineer = slice_df.loc[slice_df['job_title'] == 'Machine Learning Engineer']

#defining linear_regression functions for 4 df
def linear_regression(df):
  x = df['work_year'].values.reshape(-1, 1)
  y = df['salary_in_usd'].values.reshape(-1, 1)
  model = LinearRegression()
  model.fit(x, y)
  return model

#Forcast future salaries for next 5 years
def forcast_salary(model, year = [2025, 2026, 2027, 2028, 2029]):
  year = np.array(year).reshape(-1, 1)
  salary = model.predict(year)

  #make it into list
  salary = salary.tolist()

  #extract all five elements
  salary = [i[0] for i in salary]
  print(salary)

  #make it into dictionary
  salary = dict(zip([int(y[0]) for y in year], salary))

  #make dict to df
  salary = pd.DataFrame(salary.items(), columns=['work_year', 'salary_in_usd'])
  return salary

#make a mother function
def linear_regression_forcast(df):
  model = linear_regression(df)
  salary = forcast_salary(model)
  return salary

"""For the next step, we start by forecasting salaries for each job title's DataFrame using the `linear_regression_forcast` function. This creates projected salary data for the years 2025–2029 for each role.

Next, we calculate the standard deviation of the `salary_in_usd` column for each job title's forecasted data. The standard deviation serves as a measure of noise or variability in the projected salaries. Using these values, we define a function, `add_noise`, which takes a DataFrame and a noise factor as input. This function adds random noise to the `salary_in_usd` column within a range determined by the standard deviation, simulating variability in the salary forecasts.

After adding noise, we enhance the DataFrames by assigning a `job_title` column to each, labeling them with their respective roles (e.g., "Data Analyst," "Data Engineer"). This step ensures that the job title information is preserved when the DataFrames are combined.

Finally, we concatenate all the individual DataFrames into a single DataFrame called `forcast_df`. This unified table contains the forecasted salary data, including random noise, for all job titles. Each row includes the year, adjusted salary, and the associated job title, providing a comprehensive view of projected salary trends for the next five years.
"""

#start creating table
data_analyst = linear_regression_forcast(data_analyst)
data_engineer = linear_regression_forcast(data_engineer)
data_scientist = linear_regression_forcast(data_scientist)
machine_learning_engineer = linear_regression_forcast(machine_learning_engineer)

#find noise base on std
std_data_analyst = data_analyst['salary_in_usd'].std()
std_data_engineer = data_engineer['salary_in_usd'].std()
std_data_scientist = data_scientist['salary_in_usd'].std()
std_machine_learning_engineer = machine_learning_engineer['salary_in_usd'].std()

# Add random noise to the salary_in_usd column
def add_noise(df, noise):
    # Add random noise within the range [-noise, noise]
    df['salary_in_usd'] = df['salary_in_usd'] + np.random.uniform(-noise, noise, size=len(df))
    return df

data_analyst = add_noise(data_analyst, std_data_analyst)
data_engineer = add_noise(data_engineer, std_data_engineer)
data_scientist = add_noise(data_scientist, std_data_scientist)
machine_learning_engineer = add_noise(machine_learning_engineer, std_machine_learning_engineer)

#add tag name column
data_analyst['job_title'] = 'Data Analyst'
data_engineer['job_title'] = 'Data Engineer'
data_scientist['job_title'] = 'Data Scientist'
machine_learning_engineer['job_title'] = 'Machine Learning Engineer'

#concat
forcast_df = pd.concat([data_analyst, data_engineer, data_scientist, machine_learning_engineer])
forcast_df

"""In the final step, we visualize the forecasted salary trends for the next five years across the different data-related job roles. We use Matplotlib to create a clear and professional plot, enhancing its readability and presentation.

We start by initializing a figure and axis object with a custom size to accommodate detailed data visualization. Each job role’s forecasted salary data is plotted with distinct markers, line styles, and colors for easy differentiation. Transparency (`alpha`) is adjusted for better visibility when overlapping occurs.

The x-axis is customized to display the forecasted years, ensuring proper labeling and spacing. Titles and axis labels are styled to emphasize the purpose of the plot, with font size and bold formatting to draw attention.

The legend is positioned outside the plot area to avoid clutter and maintain clarity. It's arranged in two columns, improving the layout, especially for multiple lines, and its frame is removed for a modern look.

To enhance readability, we add a grid with a subtle dashed line style and adjust the background color of the plot and figure to soft tones, providing a visually pleasing contrast.

Finally, the layout is tightened to prevent any overlap of elements, ensuring the plot is clean and well-organized. The completed plot provides a clear, engaging, and professional depiction of salary trends across Data Analyst, Data Engineer, Data Scientist, and Machine Learning Engineer roles from 2025 to 2029.
"""

# Create the plot
fig, ax = plt.subplots(figsize=(10, 6))  # Adjust figure size for better visualization

# Plot each job type with enhancements
ax.plot(data_analyst['work_year'], data_analyst['salary_in_usd'],
        label='Data Analyst', marker='o', linestyle='-', linewidth=2, alpha=0.8)

ax.plot(data_engineer['work_year'], data_engineer['salary_in_usd'],
        label='Data Engineer', marker='s', linestyle='--', linewidth=2, alpha=0.8)

ax.plot(data_scientist['work_year'], data_scientist['salary_in_usd'],
        label='Data Scientist', marker='^', linestyle='-.', linewidth=2, alpha=0.8)

ax.plot(machine_learning_engineer['work_year'], machine_learning_engineer['salary_in_usd'],
        label='Machine Learning Engineer', marker='d', linestyle=':', linewidth=2, alpha=0.8)

# Set x-axis ticks and labels
ax.set_xticks(data_analyst['work_year'])
ax.set_xticklabels(data_analyst['work_year'], fontsize=10)

# Enhance the title and axis labels
ax.set_title('Salary Trends in Data-Related Jobs Forecast (2025-2029)', fontsize=16, fontweight='bold', pad=20)
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Salary in USD', fontsize=12)

# Customize the legend and position it outside the plot
ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1), ncol=2, fontsize=10, frameon=False)

# Add grid for better readability
ax.grid(True, linestyle='--', alpha=0.6)

# Improve the background
ax.set_facecolor('#f9f9f9')
fig.patch.set_facecolor('#ffffff')

# Show the plot
plt.tight_layout()
plt.show()

"""The graph illustrates forecasted salary trends from 2025 to 2029 for various data-related job roles: Data Analyst, Data Engineer, Data Scientist, and Machine Learning Engineer:

1. **Machine Learning Engineer**:
   - This role shows the highest projected salary growth over the years. The salary consistently increases, suggesting a strong demand for machine learning expertise and its importance in the tech industry.

2. **Data Scientist**:
   - Data Scientists also exhibit a steady upward salary trend, though the growth rate is less steep compared to Machine Learning Engineers. This trend reflects the continued relevance of data science in decision-making and business analytics.

3. **Data Engineer**:
   - The salaries for Data Engineers appear relatively stable, with minor fluctuations. This suggests that while this role remains critical for infrastructure and pipeline development, its salary growth may plateau over time.

4. **Data Analyst**:
   - Data Analysts have the lowest salaries among the four roles, but there is a gradual increase over the years. This indicates moderate growth, likely due to advancements in tools that make data analysis more accessible.

**Overall Trends**:
- The data demonstrates significant salary differences between the roles, with technical and specialized positions (e.g., Machine Learning Engineer and Data Scientist) commanding higher salaries and steeper growth trajectories.
- Data-related roles continue to show promising salary prospects, but the extent of growth varies based on technical complexity and market demand for each job.

####Display the salary changes from 2022 to 2024

For this research question, we are analyzing the change in average salary from 2022 to 2024, focusing specifically on the most popular job titles. Since there are insufficient data points for the years 2020 to 2021, we decided to exclude them from our analysis to maintain data reliability.

Our first step was to determine which job titles are most prevalent in our dataset. We did this by counting the occurrences of each job title using `df['job_title'].value_counts()`, which gives us a series of job titles and their corresponding counts. To ensure we have a substantial amount of data for each job title, we filtered this list to include only those with at least 300 records. This threshold helps us focus on roles with enough data to observe meaningful trends.

Next, we extracted the index of this filtered series, which contains the job titles that meet our criteria. We then used this index to slice our original DataFrame, creating a new subset (`slice_df`) that includes only the records for these popular job titles. This filtered dataset will allow us to accurately analyze the changes in average salary for these roles from 2022 to 2024 without the noise of less common positions or insufficient data.
"""

#find popularity of the job
slice_df = df['job_title'].value_counts()

#slice jobs that have at least 300 records
slice_df = slice_df[slice_df >= 300]

#get index
slice_df = slice_df.index

#slice df
slice_df = df.loc[df['job_title'].isin(slice_df)]

"""Next, we addressed the issue of outliers that could skew our analysis. We performed this data cleaning in two steps for each experience level—'EN' (Entry), 'MI' (Mid), 'SE' (Senior), and 'EX' (Executive). In the first step, we applied the Z-score method to remove any salary records that were more than three standard deviations away from the mean salary for their respective experience level. This helped eliminate extreme outliers that could distort the overall trends.

In the second step, we further refined our data by applying the Interquartile Range (IQR) method. For each experience level, we calculated the first quartile (Q1), third quartile (Q3), and the IQR (Q3 minus Q1). We then removed any salary records that fell outside the range of Q1 minus 1.5 times the IQR and Q3 plus 1.5 times the IQR. This additional filtering helped ensure that our dataset was as accurate and reliable as possible by excluding anomalous data points.

After cleaning the data, we proceeded to calculate the average salaries for each job title in 2022 and 2024, excluding the executive-level positions due to potential inconsistencies or lack of data. We grouped the data by 'work_year' and 'job_title' and computed the mean salary for each group. This allowed us to observe the salary trends for each job title over the three-year period.

To quantify the changes, we calculated the percentage change in average salary from 2022 to 2024 for each job title. We did this by subtracting the average salary in 2022 from the average salary in 2024, dividing the result by the 2022 average salary, and then multiplying by 100 to express it as a percentage. We rounded these values to two decimal places for clarity.

Finally, we cleaned up the results by dropping any records with missing values, which could occur if a job title did not have salary data for both years. We sorted the remaining percentage changes in descending order to highlight which job titles experienced the most significant increases or decreases in average salary between 2022 and 2024. This comprehensive analysis provided us with valuable insights into salary trends over time for the most common job roles in our dataset.
"""

#drop outlier by using z-score for every experience level using for loop
level_list = ['EN', 'MI', 'SE', 'EX']

#create a empty df
salary_change = pd.DataFrame()
salary_cahnge2 = pd.DataFrame()

for level in level_list:
  df_level = slice_df.loc[df['experience_level'] == level]
  df_level = df_level[np.abs(df_level['salary_in_usd'] - df_level['salary_in_usd'].mean()) <= 3 * df_level['salary_in_usd'].std()]
  #concat
  salary_change = pd.concat([salary_change, df_level])

#using IQR to remove outlier for each experience level using for loop
for level in level_list:
  df_level = salary_change.loc[salary_change['experience_level'] == level]
  #calculate Q1, Q3, IQR
  Q1 = df_level['salary_in_usd'].quantile(0.25)
  Q3 = df_level['salary_in_usd'].quantile(0.75)
  IQR = Q3 - Q1
  #remove outlier
  df_level = df_level[(df_level['salary_in_usd'] >= Q1 - 1.5 * IQR) & (df_level['salary_in_usd'] <= Q3 + 1.5 * IQR)]

  #concat
  salary_cahnge2 = pd.concat([salary_cahnge2, df_level])

salary_change = salary_cahnge2
salary_change

#salary change for exept EX level 2022 - 2024
salary_change2024 = salary_change.loc[salary_change['experience_level'] != 'EX']
salary_change2024 = salary_change2024.groupby(['work_year','job_title'])['salary_in_usd'].mean()

#subtract 2024 and 2022
salary_change = (salary_change2024.loc[2024] - salary_change2024.loc[2022]) / salary_change2024.loc[2022] * 100
salary_change = salary_change.round(2)

#remove nan records
salary_change = salary_change.dropna()

#sort
salary_change = salary_change.sort_values(ascending = False)
salary_change

"""We visualized the percentage change in average salary from 2022 to 2024 for each job title using a horizontal bar chart. By sorting the salary changes in ascending order, we created a clear visual representation of which job titles experienced the most significant increases or decreases over the two-year period. The x-axis displays the salary change in USD, while the y-axis lists the job titles. This visualization allows us to quickly identify trends in salary progression across different roles, providing valuable insights into how compensation has evolved for these popular positions."""

#bar chart
plt.figure(figsize=(10, 8))
salary_change.sort_values().plot(kind='barh', color='skyblue')
plt.title('Change in Average Salary from 2022 to 2024 by Job Title')
plt.xlabel('Salary Change in USD')
plt.ylabel('Job Title')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.show()

"""Our findings reveal significant variations in salary trends across different roles:

- **AI Engineer** positions experienced the highest increase, with average salaries rising by **43.01%**. This substantial growth suggests a surging demand for expertise in artificial intelligence.

- **Research Scientist**, **Machine Learning Engineer**, and **Machine Learning Researcher** roles also saw notable salary increases of **25.64%**, **24.80%**, and **23.43%** respectively. These trends indicate a strong industry focus on advanced research and development in machine learning and related fields.

- **Research Engineer** and **Data Scientist** positions witnessed moderate salary growth of **19.85%** and **13.12%**. This reflects a continued appreciation for roles that combine engineering skills with research capabilities.

- **Analytics Engineer**, **Data Engineer**, and **Data Manager** roles had smaller yet positive salary increases ranging from **4.41%** to **10.15%**. This suggests steady demand for professionals who manage and interpret data infrastructure and analytics.

- **Data Analyst** roles saw a slight decrease in average salary by **0.25%**, indicating relative stagnation in compensation for this position.

- **Data Architect** and **Applied Scientist** positions experienced salary declines of **2.73%** and **7.06%** respectively. This could imply a shifting focus away from these roles or increased supply of professionals in these areas.

- **Data Specialist** roles faced the most significant decrease, with average salaries dropping by **28.38%**. This substantial decline may suggest decreased demand or an oversupply of specialists in this field.

Our analysis highlights a clear trend: roles centered around artificial intelligence and machine learning are seeing substantial salary growth, likely due to increased investment and demand in these cutting-edge areas. Conversely, some traditional data roles are experiencing stagnant or decreasing salaries, which may be due to market saturation or evolving industry priorities favoring more advanced analytical and technological skills.

#### Top 10 Avg Highest Paying job by Experience Level

Now, we are diving into practical job insights that people might find relevant. In this step, we are analyzing a dataset to identify the top 10 job titles with the highest average salaries. To achieve this, we group the data by the `job_title` column using the `groupby` function, enabling us to calculate the mean salary for each job title based on the `salary_in_usd` column. After determining these averages, we sort them in descending order with `sort_values(ascending=False)` to highlight the highest salaries at the top. From the sorted list, we select the top 10 job titles with the highest average salaries using the `head(10)` method. Finally, we review the resulting data to explore these top-paying roles.
"""

#groupby Job title
top_10 = df.groupby('job_title')['salary_in_usd'].mean()
top_10 = top_10.sort_values(ascending = False)
top_10 = top_10.head(10)
top_10

"""For the next step, we are creating a bar chart to visualize the top 10 highest-paying jobs by experience level with improved aesthetics. First, we set the figure size to make the chart visually clear and appropriately scaled using `plt.figure(figsize=(12, 8))`. Next, we use the `plot` method on our `top_10` data to generate a bar chart, specifying a visually appealing color (`dodgerblue`) with slight transparency (`alpha=0.85`) and distinct black edges around the bars. We suppress the legend to focus on the data itself.

To enhance readability, we add a title and axis labels, adjusting the font size and weight for emphasis. The x-axis labels are rotated slightly (`rotation=45`) and aligned to the right to prevent crowding, with a comfortable font size for clarity.

We also add a grid to the chart, limiting it to the y-axis for better readability of salary values, using dashed lines with a subtle style (`--`, `linewidth=0.7`, and `alpha=0.6`). To make the chart more informative, we annotate the values above each bar. For each bar, we calculate its midpoint and height, placing a formatted salary value (`${bar.get_height():,.0f}`) above it, ensuring the text is centered and visually distinct.

Finally, we use `plt.tight_layout()` to optimize the spacing around the chart, ensuring no elements are cut off, and then display the chart with `plt.show()`. This approach results in a polished and informative visualization of the data.
"""

# Create bar chart with improved aesthetics
plt.figure(figsize=(12, 8))
bars = top_10.plot(kind='bar', color='dodgerblue', alpha=0.85, edgecolor='black', legend=False)

# Add title and labels with better font sizes
plt.title('Top 10 Highest Paying Jobs by Experience Level', fontsize=16, weight='bold')
plt.xlabel('Job Title', fontsize=14, labelpad=10)
plt.ylabel('Average Salary (USD)', fontsize=14, labelpad=10)

# Rotate x-axis labels for better readability
plt.xticks(rotation=45, ha='right', fontsize=12)

# Add grid with more subtle styling
plt.grid(axis='y', linestyle='--', linewidth=0.7, alpha=0.6)

# Add value annotations above bars
for bar in bars.patches:
    plt.text(
        bar.get_x() + bar.get_width() / 2,
        bar.get_height(),
        f'${bar.get_height():,.0f}',
        ha='center',
        va='bottom',
        fontsize=10,
        color='black'
    )

# Enhance overall layout
plt.tight_layout()

# Show the chart
plt.show()

"""From this data, we observe a clear trend in the highest-paying roles, primarily centered around leadership positions and specialized expertise in analytics, artificial intelligence, and data architecture. The top-paying role, **Analytics Engineering Manager**, has an average salary of 399,880, significantly outpacing the other roles. This suggests a high value placed on managerial positions that combine technical and strategic oversight within analytics.

The **Data Science Tech Lead**, earning an average of 375,000, highlights the premium associated with technical leadership in data science, a field crucial for driving insights and innovation. Similarly, roles like **Applied AI ML Lead** and **Head of Machine Learning**, both averaging close to or above 290,000, underscore the growing demand for senior-level expertise in machine learning and artificial intelligence.

Further down, we see technical roles such as **Machine Learning Performance Engineer** and **AWS Data Architect** maintaining competitive salaries, averaging above 250,000. This indicates that companies highly value professionals who can design scalable systems and optimize machine learning models.

Notably, leadership positions such as **Head of AI** and **Engineering Manager** also command high salaries, emphasizing the importance of guiding teams and aligning technical efforts with broader business goals. Finally, the presence of roles like **Cloud Data Architect** and **Machine Learning Model Engineer** highlights the strong demand for architects who specialize in cloud-based solutions and engineers adept at creating and refining machine learning models.

Overall, these findings suggest that roles combining technical expertise with leadership or specialized focus areas are the most lucrative, reflecting industry trends where advanced analytics, machine learning, and cloud computing drive business innovation and decision-making.

#### For nobes: Top 10 paying EN level roles (Avg)

To find out the top 10 paying EN lvel roles. We start by narrowing down the dataset to focus only on rows where the experience level is "EN" (entry-level). This allows us to concentrate specifically on entry-level positions. To achieve this, we use the `loc` method to filter the dataframe for entries with `experience_level` equal to 'EN'.

Next, we group the filtered data by the `job_title` column. This step consolidates all rows with the same job title, and for each group, we calculate the mean salary in USD using the `.mean()` function. This gives us the average salary for each job title at the entry level.

Finally, we identify the top 10 highest-paying job titles by applying the `nlargest` function. This sorts the grouped data by the average salary in descending order and extracts the 10 highest values. At the end of this process, we have a clear view of the top 10 entry-level job titles with the highest average salaries.
"""

#sort only for EN
df_en = df.loc[df['experience_level'] == 'EN']

#group job title
df_en = df_en.groupby('job_title')['salary_in_usd'].mean()

#sort top 10 paying
df_en = df_en.nlargest(10)
df_en

"""We begin by creating a gradient colormap using `LinearSegmentedColormap.from_list`. This colormap transitions smoothly between two shades of blue, "skyblue" and "dodgerblue." It will allow us to visually distinguish the bars in our plot by applying a gradient effect.

Next, we calculate the total number of bars we will plot, which corresponds to the number of rows in the `df_en` dataframe. Using this count, we generate a unique color for each bar based on the colormap. To do this, we divide the range of the colormap evenly by the number of bars and use a list comprehension to assign each bar its corresponding color.

After preparing the colors, we set up the bar plot. We use `df_en.plot` to create a bar chart, passing the calculated colors for the bars. We add some transparency with `alpha=0.85` to soften the visual effect and set `edgecolor='black'` for clear bar outlines. The figure size is set to (14, 8) for a balanced and readable chart.

We then enhance the plot's readability by adding a bold title, "Top 10 Highest Paying EN Level Jobs," and include informative axis labels for clarity. We use formatting options like `fontsize`, `weight`, and `pad` to ensure the title and labels are visually distinct and appropriately spaced.

To make the x-axis job titles easier to read, we rotate the labels by 45 degrees and align them to the right. We also add grid lines along the y-axis to help viewers compare bar heights and improve overall visualization.

Finally, we clean up the chart by hiding the top and right spines, making the design less cluttered. We apply `tight_layout` to optimize spacing and avoid overlapping elements, and then we display the plot using `plt.show()`. This results in a visually appealing and informative chart of the top 10 highest-paying entry-level job titles.
"""

# Creating a gradient colormap
cmap = LinearSegmentedColormap.from_list("gradient", ["skyblue", "dodgerblue"])

# Generate colors based on the number of bars
num_bars = len(df_en)
colors = [cmap(i / num_bars) for i in range(num_bars)]

# Creating barplot
plt.figure(figsize=(14, 8))
bars = df_en.plot(kind='bar', color=colors, alpha=0.85, edgecolor='black', legend=False)

# Enhancing the title and axis labels
plt.title('Top 10 Highest Paying EN Level Jobs', fontsize=18, weight='bold', pad=20)
plt.xlabel('Job Title', fontsize=14, labelpad=15)
plt.ylabel('Average Salary (USD)', fontsize=14, labelpad=15)

# Adjusting the x-axis ticks for better readability
plt.xticks(rotation=45, ha='right', fontsize=12)

# Adding grid lines for better visualization
plt.grid(axis='y', linestyle='--', alpha=0.6)

# Removing top and right spines for a cleaner look
plt.gca().spines['top'].set_visible(False)
plt.gca().spines['right'].set_visible(False)

plt.tight_layout()
plt.show()

"""We found that AI-related roles dominate the top-paying entry-level jobs. At the highest end, AI Researchers earn an average salary of 220,000 USD, leading the chart significantly. Machine Learning Researchers and Research Scientists follow closely with average salaries of $203,650 and 194,752 USD, respectively.

Technical engineering roles, such as Platform Engineers and Machine Learning Model Engineers, also offer high compensation, averaging 184,500 and 180,000 USD. Leadership roles in data analytics and business intelligence demonstrate strong earning potential as well, with Data Analytics Leads earning 165,350 and Business Intelligence Leads earning 150,748 USD.

Site Reliability Engineers, Machine Learning Engineers, and Machine Learning Scientists round out the list with competitive average salaries ranging between 146,735 and 148,580 USD. These findings highlight the premium placed on technical expertise and leadership in data, AI, and engineering fields.

### Practical Recommendations

**Recommendations for Job Seekers and HR Professionals**

**Recommendations for Entry-Level Roles with High Salary Potential**

* AI Researcher, Machine Learning Researcher, Research Scientist: These roles offer the highest average salaries for entry-level positions (\$194,752 to \$220,000). Competitive compensation and clear growth opportunities are crucial to attract talent, and targeting these positions can maximize earning potential early in your career.

* Platform Engineer, Machine Learning Model Engineer, Data Analytics Lead: These roles offer competitive salaries (\$165,350 to \$184,500). Building skills in engineering and data analytics can help secure these high-paying roles, and providing strong entry-level packages can help secure top talent.

* High Salary Roles: Roles like AI Researcher, Machine Learning Researcher, and Research Scientist offer the highest salaries for entry-level positions. Competitive compensation and clear growth opportunities are crucial to attract talent.

* Competitive Packages: Roles such as Platform Engineer and Data Analytics Lead have competitive salaries. Providing strong entry-level packages can help secure top talent.

**Recommendations for High Paying Roles by Experience Level**

* Analytics Engineering Manager, Data Science Tech Lead, Applied AI ML Lead: These advanced roles have the highest average salaries, ranging from \$292,500 to \$399,880. Pursuing advanced technical and leadership skills can help you qualify for these top-paying positions, while HR should ensure competitive compensation to attract and retain top-tier talent.

* Head of Machine Learning, Machine Learning Performance Engineer, Engineering Manager: These leadership roles offer salaries up to \$288,701. Building leadership and specialized skills can increase your chances of obtaining these high-paying positions, and HR should focus on offering career growth opportunities to attract talent.

* AWS Data Architect, Head of AI, Cloud Data Architect, Machine Learning Model Engineer: Roles focusing on cloud architecture and AI leadership offer competitive salaries (\$245,625 to \$258,000). Specializing in these fields can enhance earning potential, and HR should offer attractive compensation for these specialized roles.

* Leadership and Technical Roles: Roles like Analytics Engineering Manager and Head of Machine Learning offer high salaries. Ensuring competitive compensation and career growth opportunities is key to attracting and retaining top-tier talent.

**Recommendations Based on Salary Growth and Decline Trends (2022 - 2024)**

* High Growth Roles: Roles like AI Engineer, Research Scientist, and Machine Learning Engineer have experienced substantial salary growth, indicating strong demand. Targeting these fields can maximize earning potential, and offering competitive compensation aligned with market trends can help attract talent.

* Roles with Salary Decline: Roles such as Data Analyst, Data Architect, and Applied Scientist have experienced salary decreases. Consider further specialization or transitioning to higher-demand roles to improve earning potential, while HR should offer incentives, training, or career growth opportunities to retain talent in these roles.

* High Growth Roles: Roles like AI Engineer and Machine Learning Engineer have shown significant salary growth. Offering competitive compensation aligned with market trends can help attract talent.

* Salary Decline Roles: Roles like Data Analyst and Data Specialist have experienced salary decreases. Offering incentives, training, or career growth opportunities can help retain talent in these roles.

**Recommendations Based on Salary Trends Across Job Roles (2020 - 2024)**

* Data Analysts, Data Engineers, Data Scientists, Machine Learning Engineers: Salaries across these roles have generally increased from 2020 to 2024, with Machine Learning Engineers showing the steepest rise. Focusing on technical skills and staying current with industry trends can lead to salary growth, and HR should ensure competitive salaries and career development opportunities to attract talent in these high-demand roles.

* Data and Machine Learning Roles: Salaries have generally increased, particularly for Machine Learning Engineers. Competitive salaries and career development opportunities can help attract talent in these high-demand roles.

**Recommendations on Impact of Remote Work on Salary**

* Onsite vs. Remote Roles: Onsite roles offer higher average salaries (\$162,186) compared to fully remote roles (\$149,491). If maximizing salary is a priority, consider onsite opportunities, while HR should consider offering higher compensation for onsite roles to attract talent, and ensure remote roles remain attractive through competitive pay and flexibility.

* Onsite vs. Remote Roles: Onsite roles command higher salaries. Consider offering higher compensation for onsite roles to attract talent, while ensuring remote roles remain attractive through competitive pay and flexibility.

**Recommendations on Salary Differences by Company Size and Experience Level**

* Entry-Level to Executive-Level: Medium-sized companies tend to offer the highest salaries across most experience levels. Targeting medium-sized firms may provide better compensation, while HR should emphasize unique benefits and competitive salaries to attract top talent.

* Medium-Sized Companies: Medium-sized companies generally offer the highest salaries, particularly for executive-level roles. Emphasizing unique benefits and competitive salaries can help attract top talent.

**Recommendations on Average Salary by Employment Type and Experience Level**

* Entry-Level to Executive-Level: Full-time roles generally offer the highest salaries across all experience levels, but contract roles also provide competitive compensation. Prioritizing full-time employment may maximize earnings, while HR should ensure attractive compensation packages for both employment types to secure diverse talent.

* Full-Time vs. Contract Roles: Full-time roles offer the highest salaries across experience levels, but contract roles also provide competitive compensation. Ensuring attractive compensation packages for both employment types can help secure diverse talent.

**Recommendations Based on Top/Bottom 10 Country Locations by Average Salary**

* Top Earning Countries: Countries like Qatar, Venezuela, and the United States offer the highest average salaries. Consider exploring opportunities in these countries to maximize earnings, while HR should use these countries as benchmarks for competitive salaries and provide attractive compensation packages to attract international talent.

* Lower Earning Countries: In countries with lower average salaries, such as Malaysia and Ecuador, building specialized skills or seeking remote work with companies from higher-paying countries can help improve earning potential, while HR should focus on non-monetary benefits, career development, and training programs to retain talent.

* Benchmarking Compensation: Use countries like Qatar and the United States as benchmarks for competitive salaries. Providing attractive compensation packages can help attract international talent.

* Retention Strategies: In lower-paying countries, focus on non-monetary benefits, career development, and training programs to retain talent.

### Summary and Conclusions

Our report analyzed salary trends across AI, Machine Learning, Data Science, and related fields, focusing on the influence of factors such as experience level, company size, employment type, remote work ratio, and regional disparities. We identified key trends, including a positive correlation between experience and salary, the dominance of medium-sized companies in providing competitive compensation, and the higher pay associated with on-site roles compared to fully remote positions. High-demand roles like Machine Learning Engineer and AI Researcher consistently offered top-tier salaries, while entry-level positions such as Data Analyst showed lower compensation but served as stepping stones for career growth. However, the dataset had limitations, including a heavy skew toward roles in the Americas, particularly the United States, and limited representation of earlier years and emerging roles. These constraints restricted the depth of regional and historical insights. If given more time, we would address these shortcomings by expanding the dataset, incorporating emerging roles, and employing advanced forecasting methods to account for market volatility. This would allow for a more comprehensive understanding of salary trends and provide deeper insights into workforce dynamics.

### Bibliography (5 points)
Foorilla. (2024). Get a full dataset of global AI, ML, Data salaries. https://aijobs.net/salaries/download/

Lukes. (n.d.). ISO-3166-countries-with-regional-codes/all/all.csv at master · Lukes/ISO-3166-Countries-with-regional-codes. GitHub. https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes/blob/master/all/all.csv
"""